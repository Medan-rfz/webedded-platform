// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package auth

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addRefreshToken = `-- name: AddRefreshToken :exec
INSERT INTO "JwtRefresh" 
(user_id, refresh_token, expires_at)
VALUES ($1, $2, $3)
`

type AddRefreshTokenParams struct {
	UserID       pgtype.Int8      `json:"user_id"`
	RefreshToken string           `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) AddRefreshToken(ctx context.Context, arg AddRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, addRefreshToken, arg.UserID, arg.RefreshToken, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO "Users" 
(email, first_name, last_name, "group")
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateUserParams struct {
	Email     string      `json:"email"`
	FirstName string      `json:"first_name"`
	LastName  string      `json:"last_name"`
	Group     pgtype.Text `json:"group"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Group,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAuthByEmail = `-- name: GetAuthByEmail :one
SELECT u.id, u.email, cr.password_hash 
FROM "Users" u
JOIN "Credentials" cr ON u.id = cr.user_id
WHERE u.email = $1
`

type GetAuthByEmailRow struct {
	ID           int64  `json:"id"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) GetAuthByEmail(ctx context.Context, email string) (GetAuthByEmailRow, error) {
	row := q.db.QueryRow(ctx, getAuthByEmail, email)
	var i GetAuthByEmailRow
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const getAuthById = `-- name: GetAuthById :one
SELECT u.id, u.email, cr.password_hash 
FROM "Users" u
JOIN "Credentials" cr ON u.id = cr.user_id
WHERE u.id = $1
`

type GetAuthByIdRow struct {
	ID           int64  `json:"id"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) GetAuthById(ctx context.Context, id int64) (GetAuthByIdRow, error) {
	row := q.db.QueryRow(ctx, getAuthById, id)
	var i GetAuthByIdRow
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const getByEmail = `-- name: GetByEmail :one
SELECT u.id, u.email, cr.password_hash 
FROM "Users" u
JOIN "Credentials" cr ON u.id = cr.user_id
WHERE u.email = $1
`

type GetByEmailRow struct {
	ID           int64  `json:"id"`
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) GetByEmail(ctx context.Context, email string) (GetByEmailRow, error) {
	row := q.db.QueryRow(ctx, getByEmail, email)
	var i GetByEmailRow
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHash)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT r.id, r.refresh_token, r.expires_at
FROM "JwtRefresh" r
WHERE r.refresh_token = $1
`

type GetRefreshTokenRow struct {
	ID           int64            `json:"id"`
	RefreshToken string           `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) GetRefreshToken(ctx context.Context, refreshToken string) (GetRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, refreshToken)
	var i GetRefreshTokenRow
	err := row.Scan(&i.ID, &i.RefreshToken, &i.ExpiresAt)
	return i, err
}

const insertCredentials = `-- name: InsertCredentials :exec
INSERT INTO "Credentials" (user_id, password_hash)
VALUES ($1, $2)
`

type InsertCredentialsParams struct {
	UserID       int64  `json:"user_id"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) InsertCredentials(ctx context.Context, arg InsertCredentialsParams) error {
	_, err := q.db.Exec(ctx, insertCredentials, arg.UserID, arg.PasswordHash)
	return err
}
